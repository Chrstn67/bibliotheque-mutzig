// vike.ts
import fs from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";
import { prerender as prerenderCli } from "vike/prerender";
import { normalizePath } from "vite";
import "vike/__internal/setup";
import { newError } from "@brillout/libassert";
import { nanoid } from "nanoid";
import { getPagesAndRoutes, route } from "vike/__internal";

// route-regex.ts
function getSegmentRegex(segment) {
  if (segment.startsWith("@")) {
    return "/[^/]+";
  }
  if (segment === "*") {
    return "/.+?";
  }
  return `/${segment}`;
}
function getParametrizedRoute(route2) {
  const segments = (route2.replace(/\/$/, "") || "/").slice(1).split("/");
  return segments.map(getSegmentRegex).join("");
}

// vike.ts
var libName = "vite-plugin-vercel:vike";
var rendererDestination = "ssr_";
var __dirname = path.dirname(fileURLToPath(import.meta.url));
function assert(condition, errorMessage) {
  if (condition) {
    return;
  }
  const err = newError(`[${libName}][Wrong Usage] ${errorMessage}`, 2);
  throw err;
}
function getRoot(config) {
  return normalizePath(config.root || process.cwd());
}
function getOutDirRoot(config) {
  const outDir = config.build.outDir;
  return outDir.endsWith("/server") || outDir.endsWith("/client") ? path.normalize(path.join(outDir, "..")) : outDir;
}
function getOutput(config, suffix) {
  return path.join(
    config.vercel?.outDir ? "" : getRoot(config),
    config.vercel?.outDir ?? ".vercel/output",
    suffix ?? ""
  );
}
function getOutDir(config, force) {
  const p = path.join(config.root, normalizePath(config.build.outDir));
  if (!force) return p;
  return path.join(path.dirname(p), force);
}
async function copyDir(src, dest) {
  await fs.mkdir(dest, { recursive: true });
  const entries = await fs.readdir(src, { withFileTypes: true });
  for (const entry of entries) {
    const srcPath = path.join(src, entry.name);
    const destPath = path.join(dest, entry.name);
    if (entry.isDirectory()) {
      await copyDir(srcPath, destPath);
    } else {
      await fs.copyFile(srcPath, destPath);
    }
  }
}
function assertHeaders(exports) {
  if (exports === null || typeof exports !== "object") return null;
  if (!("headers" in exports)) return null;
  const headers = exports.headers;
  if (headers === null || headers === void 0) {
    return null;
  }
  assert(typeof headers === "object", " `{ headers }` must be an object");
  for (const value of Object.values(headers)) {
    assert(typeof value === "string", " `{ headers }` must only contains string values");
  }
  return headers;
}
function assertEdge(exports) {
  if (exports === null || typeof exports !== "object") return null;
  if (!("edge" in exports)) return null;
  const edge = exports.edge;
  assert(typeof edge === "boolean", " `{ edge }` must be a boolean");
  return edge;
}
function extractIsr(exports) {
  if (exports === null || typeof exports !== "object") return null;
  if (!("isr" in exports)) return null;
  const isr = exports.isr;
  assert(
    typeof isr === "boolean" || typeof isr === "object" && typeof isr.expiration === "number" && isr.expiration > 0,
    " `{ expiration }` must be a positive number"
  );
  return isr;
}
function assertIsr(resolvedConfig, exports) {
  const isr = extractIsr(exports);
  if (isr === null || isr === void 0) return null;
  if (isr === true) {
    assert(
      typeof resolvedConfig.vercel?.expiration === "number" && resolvedConfig.vercel?.expiration > 0,
      "`export const isr = true;` requires a default positive value for `expiration` in vite config"
    );
    return resolvedConfig.vercel?.expiration;
  }
  return isr.expiration;
}
function getRouteMatch(myroute) {
  let routeMatch = null;
  if ("_routeMatch" in myroute.pageContextAddendum) {
    routeMatch = myroute.pageContextAddendum._routeMatch;
  } else if ("_routeMatches" in myroute.pageContextAddendum) {
    routeMatch = myroute.pageContextAddendum._routeMatches?.[0];
  } else if ("_debugRouteMatches" in myroute.pageContextAddendum) {
    routeMatch = myroute.pageContextAddendum._debugRouteMatches?.[0];
  }
  return routeMatch;
}
var prerender = async (resolvedConfig) => {
  const routes = {};
  await prerenderCli({
    viteConfig: {
      root: getRoot(resolvedConfig),
      build: {
        outDir: getOutDirRoot(resolvedConfig)
      }
    },
    async onPagePrerender(pageContext) {
      const { filePath, fileContent } = pageContext._prerenderResult;
      const isr = assertIsr(resolvedConfig, pageContext.exports);
      const foundRoute = await route(pageContext);
      if (!pageContext.is404) {
        assert(foundRoute, `Page with id ${pageContext.pageId ?? pageContext._pageId} not found`);
        const routeMatch = getRouteMatch(foundRoute);
        if (typeof isr === "number" && routeMatch && typeof routeMatch !== "string" && routeMatch.routeType === "FILESYSTEM") {
          return;
        }
      }
      const relPath = path.relative(getOutDir(resolvedConfig, "client"), filePath);
      const newFilePath = path.join(getOutput(resolvedConfig, "static"), relPath);
      const parsed = path.parse(relPath);
      const pathJoined = parsed.name === "index" ? parsed.dir : path.join(parsed.dir, parsed.name);
      if (relPath.endsWith(".html")) {
        routes[relPath] = {
          path: pathJoined === "index" ? "" : pathJoined
        };
      }
      await fs.mkdir(path.dirname(newFilePath), { recursive: true });
      await fs.writeFile(newFilePath, fileContent);
    }
  });
  return routes;
};
function getRouteDynamicRoute(pageRoutes, pageId) {
  for (const route2 of pageRoutes) {
    if (route2.pageId === pageId) {
      if (route2.routeType === "STRING") {
        return getParametrizedRoute(route2.routeString);
      }
      if (route2.routeType === "FUNCTION") {
        return () => {
        };
      }
    }
  }
  return null;
}
function getRouteFsRoute(pageRoutes, pageId) {
  for (const route2 of pageRoutes) {
    if (route2.pageId === pageId && route2.routeType === "FILESYSTEM") {
      return route2.routeString;
    }
  }
  return null;
}
async function getSsrEdgeEndpoint() {
  const sourcefile = path.join(__dirname, "..", "templates", "ssr_edge_.template.ts");
  const contents = await fs.readFile(sourcefile, "utf-8");
  const resolveDir = path.dirname(sourcefile);
  return {
    contents,
    sourcefile,
    loader: sourcefile.endsWith(".ts") ? "ts" : sourcefile.endsWith(".tsx") ? "tsx" : sourcefile.endsWith(".js") ? "js" : sourcefile.endsWith(".jsx") ? "jsx" : "default",
    resolveDir
  };
}
async function getSsrEndpoint(source) {
  const sourcefile = source ?? path.join(__dirname, "..", "templates", "ssr_.template.ts");
  const contents = await fs.readFile(sourcefile, "utf-8");
  const resolveDir = path.dirname(sourcefile);
  return {
    source: {
      contents,
      sourcefile,
      loader: sourcefile.endsWith(".ts") ? "ts" : sourcefile.endsWith(".tsx") ? "tsx" : sourcefile.endsWith(".js") ? "js" : sourcefile.endsWith(".jsx") ? "jsx" : "default",
      resolveDir
    },
    destination: rendererDestination,
    route: false
  };
}
function vikeVercelPlugin(options = {}) {
  return {
    name: libName,
    apply: "build",
    async config(userConfig) {
      if (!userConfig.build?.ssr) return {};
      const getSsrEndpointIfNotPresent = async (endpoints) => {
        return endpoints.flatMap((e) => e.destination).some((d) => d === rendererDestination) ? (
          // vite deep merges config
          []
        ) : [await getSsrEndpoint()];
      };
      const additionalEndpoints = [
        async () => {
          const userEndpoints = [];
          if (Array.isArray(userConfig.vercel?.additionalEndpoints)) {
            for (const endpoint of userConfig.vercel.additionalEndpoints) {
              if (typeof endpoint === "function") {
                const res = await endpoint();
                if (Array.isArray(res)) {
                  userEndpoints.push(...res);
                } else {
                  userEndpoints.push(res);
                }
              } else {
                userEndpoints.push(endpoint);
              }
            }
          }
          return getSsrEndpointIfNotPresent(userEndpoints);
        }
      ];
      return {
        vitePluginSsr: {
          prerender: {
            disableAutoRun: true
          }
        },
        vercel: {
          prerender: userConfig.vercel?.prerender ?? prerender,
          additionalEndpoints,
          defaultSupportsResponseStreaming: true,
          rewrites: [
            {
              source: options.source ? `(${options.source})` : "((?!/api).*)",
              destination: `/${rendererDestination}/?__original_path=$1`,
              enforce: "post"
            }
          ]
        }
      };
    }
  };
}
function findPageFile(pageId, pageFilesAll) {
  return pageFilesAll.find((p) => p.pageId === pageId && p.fileType === ".page");
}
function vitePluginVercelVikeConfigPlugin() {
  return {
    name: "vite-plugin-vercel:vike-config",
    apply: "build",
    async config(userConfig) {
      let memoizedP = void 0;
      async function getPagesWithConfigs() {
        if (memoizedP) return memoizedP;
        memoizedP = _getPagesWithConfigs();
        return memoizedP;
      }
      async function _getPagesWithConfigs() {
        const { pageFilesAll, allPageIds, pageRoutes, pageConfigs } = await getPagesAndRoutes();
        const isLegacy = pageFilesAll.length > 0;
        if (isLegacy) {
          await Promise.all(pageFilesAll.map((p) => p.loadFile?.()));
        }
        return Promise.all(
          allPageIds.map(async (pageId) => {
            let page;
            if (isLegacy) {
              const _page = await findPageFile(pageId, pageFilesAll);
              assert(
                _page,
                `Cannot find page ${pageId}. Contact the vite-plugin-vercel maintainer on GitHub / Discord`
              );
              page = {
                config: _page.fileExports,
                filePath: _page.filePath
              };
            } else {
              const pageConfig = pageConfigs.find((p) => p.pageId === pageId);
              assert(
                pageConfig,
                `Cannot find page config ${pageId}. Contact the vite-plugin-vercel maintainer on GitHub / Discord`
              );
              const simplePageConfig = {};
              for (const [k, v] of Object.entries(pageConfig.configValues)) {
                simplePageConfig[k] = v.value;
              }
              page = {
                config: simplePageConfig,
                filePath: pageConfig.pageId
              };
            }
            const route2 = getRouteDynamicRoute(pageRoutes, pageId) ?? getRouteFsRoute(pageRoutes, pageId);
            const rawIsr = extractIsr(page.config);
            let isr = assertIsr(userConfig, page.config);
            const edge = assertEdge(page.config);
            const headers = assertHeaders(page.config);
            if (typeof route2 === "function" && isr) {
              console.warn(
                `Page ${pageId}: ISR is not supported when using route function. Remove \`{ isr }\` config or use a route string if possible.`
              );
              isr = null;
            }
            if (edge && rawIsr !== null && typeof rawIsr === "object") {
              throw new Error(
                `Page ${pageId}: ISR cannot be enabled for edge functions. Remove \`{ isr }\` config or set \`{ edge: false }\`.`
              );
            }
            return {
              pageId,
              // used for debug purpose
              filePath: page.filePath,
              isr,
              edge,
              headers,
              route: typeof route2 === "string" ? getParametrizedRoute(route2) : null
            };
          })
        );
      }
      const edgeSource = await getSsrEdgeEndpoint();
      return {
        vercel: {
          async headers() {
            const pagesWithConfigs = await getPagesWithConfigs();
            return pagesWithConfigs.filter((page) => {
              if (!page.route) {
                console.warn(
                  `Page ${page.pageId}: headers is not supported when using route function. Remove \`{ headers }\` config or use a route string if possible.`
                );
              }
              return page.headers !== null && page.headers !== void 0 && page.route;
            }).flatMap((page) => {
              const headers = Object.entries(page.headers ?? {}).map(([key, value]) => ({
                key,
                value
              }));
              return [
                {
                  source: `${page.route}`,
                  headers
                },
                {
                  source: `${page.route}/index\\.pageContext\\.json`,
                  headers
                }
              ];
            });
          },
          additionalEndpoints: [
            async () => {
              const pagesWithConfigs = await getPagesWithConfigs();
              return pagesWithConfigs.filter((page) => {
                return page.edge === true;
              }).map((page) => {
                if (!page.route) {
                  console.warn(
                    `Page ${page.pageId}: edge is not supported when using route function. Remove \`{ edge }\` config or use a route string if possible.`
                  );
                }
                const destination = `${page.pageId.replace(/\/index$/g, "")}-edge-${nanoid()}`;
                return {
                  source: edgeSource,
                  destination,
                  route: page.route ? `${page.route}(?:\\/index\\.pageContext\\.json)?` : void 0,
                  edge: true
                };
              });
            }
          ],
          isr: async () => {
            let userIsr = {};
            if (userConfig.vercel?.isr) {
              if (typeof userConfig.vercel.isr === "function") {
                userIsr = await userConfig.vercel.isr();
              } else {
                userIsr = userConfig.vercel.isr;
              }
            }
            const pagesWithConfigs = await getPagesWithConfigs();
            return pagesWithConfigs.filter((p) => typeof p.isr === "number").reduce((acc, cur) => {
              const path2 = `${cur.pageId.replace(/\/index$/g, "")}-${nanoid()}`;
              acc[path2] = {
                // biome-ignore lint/style/noNonNullAssertion: filtered
                expiration: cur.isr,
                symlink: rendererDestination,
                route: cur.route ? `${cur.route}(?:\\/index\\.pageContext\\.json)?` : void 0
              };
              return acc;
            }, userIsr);
          }
        }
      };
    }
  };
}
function vitePluginVercelVikeCopyStaticAssetsPlugins() {
  let resolvedConfig;
  return {
    apply: "build",
    name: "vite-plugin-vercel:vike-copy-static-assets",
    enforce: "post",
    configResolved(config) {
      resolvedConfig = config;
    },
    async closeBundle() {
      if (!resolvedConfig.build?.ssr) return;
      await copyDistClientToOutputStatic(resolvedConfig);
    }
  };
}
async function copyDistClientToOutputStatic(resolvedConfig) {
  await copyDir(getOutDir(resolvedConfig, "client"), getOutput(resolvedConfig, "static"));
}
function allPlugins(options = {}) {
  return [vitePluginVercelVikeConfigPlugin(), vikeVercelPlugin(options), vitePluginVercelVikeCopyStaticAssetsPlugins()];
}
export {
  assert,
  allPlugins as default,
  getOutDir,
  getOutput,
  getRoot,
  getSsrEdgeEndpoint,
  getSsrEndpoint,
  prerender,
  vikeVercelPlugin,
  vitePluginVercelVikeConfigPlugin,
  vitePluginVercelVikeCopyStaticAssetsPlugins
};
